/**
 * ==========================================================================
 * Array Utilities
 * ==========================================================================
 */

/**
 * Checks if a value is an array.
 * @param value - The value to check.
 * @returns True if the value is an array, false otherwise.
 */
function isArray<T>(value: any): value is T[] {
  return Array.isArray(value);
}

/**
 * Shuffles an array in place using the Fisher-Yates algorithm.
 * @template T
 * @param {T[] | null | undefined} array - The array to shuffle. If null or undefined, an empty array is returned.
 * @returns {T[]} The shuffled array (mutated if it was an array, otherwise a new empty array).
 */
export function shuffle<T>(array: T[] | null | undefined): T[] {
  if (!isArray(array) || array.length === 0) {
    return [];
  }
  // Iterate downwards to ensure each element is swapped at most once
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1)); // Random index from 0 to i
    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
  }
  return array; // Returns the original array, mutated
}

/**
 * Creates a new array with unique values from the input array.
 * For arrays of primitives. For objects, it checks reference equality.
 * @template T
 * @param {T[] | null | undefined} array - The array to get unique values from. If null or undefined, an empty array is returned.
 * @returns {T[]} A new array with unique values.
 */
export function unique<T>(array: T[] | null | undefined): T[] {
  if (!isArray(array)) {
    return [];
  }
  return [...new Set(array)];
}

/**
 * A type for the key generated by groupBy or keyBy functions.
 */
type GroupKey = string | number | symbol;

/**
 * Groups elements of an array based on a given key or a callback function.
 * @template T - The type of elements in the array.
 * @template K - The type of the key to group by (string, number, or symbol).
 * @param {T[] | null | undefined} array - The array to group. If null or undefined, an empty object is returned.
 * @param {keyof T | ((item: T) => K)} keyOrFn - A property name of T or a function that returns the grouping key for an item.
 * @returns {Record<K, T[]>} An object where keys are group identifiers and values are arrays of elements.
 */
export function groupBy<T, K extends GroupKey>(
  array: T[] | null | undefined,
  keyOrFn: keyof T | ((item: T) => K)
): Record<K, T[]> {
  if (!isArray(array)) {
    return {} as Record<K, T[]>;
  }
  return array.reduce((result, item) => {
    const key: K =
      typeof keyOrFn === 'function' ? keyOrFn(item) : (item[keyOrFn as keyof T] as unknown as K); // Type assertion needed if keyof T is not directly assignable to K

    // Ensure result[key] is initialized as an array
    if (!result[key]) {
      result[key] = [];
    }
    result[key].push(item);
    return result;
  }, {} as Record<K, T[]>);
}

/**
 * Gets the first element of an array.
 * @template T
 * @param {T[] | null | undefined} array - The array.
 * @returns {T | undefined} The first element, or undefined if the array is empty, null, or undefined.
 */
export function first<T>(array: T[] | null | undefined): T | undefined {
  if (!isArray(array) || array.length === 0) {
    return undefined;
  }
  return array[0];
}

// Alias for first
export const head = first;

/**
 * Gets the last element of an array.
 * @template T
 * @param {T[] | null | undefined} array - The array.
 * @returns {T | undefined} The last element, or undefined if the array is empty, null, or undefined.
 */
export function last<T>(array: T[] | null | undefined): T | undefined {
  if (!isArray(array) || array.length === 0) {
    return undefined;
  }
  return array[array.length - 1];
}

/**
 * Gets all but the first element of an array.
 * @template T
 * @param {T[] | null | undefined} array - The array.
 * @returns {T[]} A new array containing all elements except the first. Returns an empty array if input is not an array or has less than 2 elements.
 */
export function tail<T>(array: T[] | null | undefined): T[] {
  if (!isArray(array) || array.length < 2) {
    return [];
  }
  return array.slice(1);
}

/**
 * Removes falsy values (false, null, 0, "", undefined, NaN) from an array.
 * @template T
 * @param {(T | null | undefined | false | 0 | '')[] | null | undefined} array - The array to compact.
 * @returns {T[]} A new array with falsy values removed.
 */
export function compact<T>(
  array: (T | null | undefined | false | 0 | '')[] | null | undefined
): T[] {
  if (!isArray(array)) {
    return [];
  }
  return array.filter(Boolean) as T[];
}

/**
 * Flattens a nested array up to a specified depth.
 * @template T
 * @param {(T | T[] | (T | T[])[])[] | null | undefined} array - The array to flatten. (Allows for various levels of nesting)
 * @param {number} [depth=1] - The maximum recursion depth.
 * @returns {any[]} A new flattened array. Type is 'any[]' because deep flattening complex types is hard to type perfectly.
 * For known structures, consider a more specific return type or using `flatMap`.
 */
export function flatten<T>(
  array: (T | any[])[] | null | undefined, // Simplified input type for broader applicability
  depth: number = 1
): any[] {
  // Return type is any[] due to the complexity of deeply nested types
  if (!isArray(array)) {
    return [];
  }
  if (depth < 1) {
    return array.slice(); // Return a shallow copy if depth is 0 or less
  }
  return array.reduce<any[]>((acc, val) => {
    if (isArray(val)) {
      acc.push(...flatten(val, depth - 1));
    } else {
      acc.push(val);
    }
    return acc;
  }, []);
}

/**
 * A simpler version of flatten that flattens an array one level deep.
 * @template T
 * @param {(T | T[])[] | null | undefined} array - The array to flatten.
 * @returns {T[]} A new array flattened one level deep.
 */
export function flattenOnce<T>(array: (T | T[])[] | null | undefined): T[] {
  if (!isArray(array)) {
    return [];
  }
  return array.reduce<T[]>((acc, val) => {
    if (isArray(val)) {
      acc.push(...val);
    } else {
      acc.push(val);
    }
    return acc;
  }, []);
}

/**
 * Splits an array into chunks of a specified size.
 * @template T
 * @param {T[] | null | undefined} array - The array to chunk.
 * @param {number} [size=1] - The size of each chunk. Must be a positive integer.
 * @returns {T[][]} A new array containing the chunks. Returns an empty array if input is not an array or size is invalid.
 */
export function chunk<T>(array: T[] | null | undefined, size: number = 1): T[][] {
  if (!isArray(array) || size < 1) {
    return [];
  }
  const result: T[][] = [];
  const numChunks = Math.ceil(array.length / size);
  for (let i = 0; i < numChunks; i++) {
    result.push(array.slice(i * size, (i + 1) * size));
  }
  return result;
}

/**
 * Creates an array of values not included in the other given arrays.
 * Uses Set for efficient lookups.
 * @template T
 * @param {T[] | null | undefined} array - The array to inspect.
 * @param {...(T[] | null | undefined)[]} valuesToExcludeArrays - Arrays of values to exclude.
 * @returns {T[]} A new array of filtered values.
 */
export function difference<T>(
  array: T[] | null | undefined,
  ...valuesToExcludeArrays: (T[] | null | undefined)[]
): T[] {
  if (!isArray(array)) {
    return [];
  }
  if (valuesToExcludeArrays.length === 0) {
    return array.slice(); // Return a copy if no values to exclude
  }

  const excludeSet = new Set<T>();
  for (const arr of valuesToExcludeArrays) {
    if (isArray(arr)) {
      arr.forEach((val) => excludeSet.add(val));
    }
  }

  return array.filter((item) => !excludeSet.has(item));
}

/**
 * Creates an array of unique values that are included in all given arrays.
 * @template T
 * @param {...(T[] | null | undefined)[]} arrays - The arrays to inspect.
 * @returns {T[]} A new array of shared values.
 */
export function intersection<T>(...arrays: (T[] | null | undefined)[]): T[] {
  const validArrays = arrays.filter(isArray) as T[][];
  if (validArrays.length === 0) {
    return [];
  }
  if (validArrays.length === 1) {
    return unique(validArrays[0]); // Return unique values of the single array
  }

  // Start with the unique elements of the first array
  let result = unique(validArrays[0]);

  // Intersect with the rest of the arrays
  for (let i = 1; i < validArrays.length; i++) {
    const currentArraySet = new Set(validArrays[i]);
    result = result.filter((item) => currentArraySet.has(item));
    if (result.length === 0) break; // Early exit if intersection is empty
  }
  return result;
}

/**
 * Creates an array of unique values from all given arrays.
 * @template T
 * @param {...(T[] | null | undefined)[]} arrays - The arrays to combine.
 * @returns {T[]} A new array of unique values.
 */
export function union<T>(...arrays: (T[] | null | undefined)[]): T[] {
  const result = new Set<T>();
  for (const arr of arrays) {
    if (isArray(arr)) {
      arr.forEach((item) => result.add(item));
    }
  }
  return [...result];
}

/**
 * Gets a random element from an array.
 * @template T
 * @param {T[] | null | undefined} array - The array.
 * @returns {T | undefined} A random element, or undefined if the array is empty, null, or undefined.
 */
export function sample<T>(array: T[] | null | undefined): T | undefined {
  if (!isArray(array) || array.length === 0) {
    return undefined;
  }
  return array[Math.floor(Math.random() * array.length)];
}

/**
 * Gets n random elements from an array, without repetition.
 * @template T
 * @param {T[] | null | undefined} array - The array.
 * @param {number} [n=1] - The number of elements to sample.
 * @returns {T[]} An array of n random elements. Returns an empty array if input is invalid or n is non-positive.
 * If n is greater than array length, returns a shuffled copy of the array.
 */
export function sampleSize<T>(array: T[] | null | undefined, n: number = 1): T[] {
  if (!isArray(array) || array.length === 0 || n < 1) {
    return [];
  }
  if (n >= array.length) {
    return shuffle(array.slice()); // Return a shuffled copy of the whole array
  }
  // Fisher-Yates variant to get n samples
  const result = array.slice(); // Create a copy
  for (let i = 0; i < n; i++) {
    const randomIndex = i + Math.floor(Math.random() * (result.length - i));
    [result[i], result[randomIndex]] = [result[randomIndex], result[i]];
  }
  return result.slice(0, n);
}

/**
 * Sums the values returned by an iteratee for each element in the array.
 * @template T
 * @param {T[] | null | undefined} array - The array to iterate over.
 * @param {keyof T | ((item: T) => number)} iteratee - The property name (if T is an object and property value is number) or function producing the value to sum.
 * @returns {number} The sum of the iterated values.
 */
export function sumBy<T>(
  array: T[] | null | undefined,
  iteratee: keyof T | ((item: T) => number)
): number {
  if (!isArray(array) || array.length === 0) {
    return 0;
  }
  let sum = 0;
  const getValue = typeof iteratee === 'function' ? iteratee : (item: T) => Number(item[iteratee]); // Ensure the property is treated as a number

  for (const item of array) {
    sum += getValue(item);
  }
  return sum;
}

/**
 * Computes the average of the values returned by an iteratee for each element in the array.
 * @template T
 * @param {T[] | null | undefined} array - The array to iterate over.
 * @param {keyof T | ((item: T) => number)} iteratee - The property name or function producing the value.
 * @returns {number} The average of the iterated values, or 0 if the array is empty.
 */
export function averageBy<T>(
  array: T[] | null | undefined,
  iteratee: keyof T | ((item: T) => number)
): number {
  if (!isArray(array) || array.length === 0) {
    return 0;
  }
  const totalSum = sumBy(array, iteratee);
  return totalSum / array.length;
}

/**
 * Creates an object composed of keys generated from the results of running each element of collection thru iteratee.
 * The order of iteratees use the same order as the results of iterating over the collection.
 * If multiple items map to the same key, the last one encountered will be in the result.
 * @template T - The type of elements in the array.
 * @template K - The type of the key to group by (string, number, or symbol).
 * @param {T[] | null | undefined} array - The array to iterate over.
 * @param {keyof T | ((item: T) => K)} iteratee - The property name of T or a function that returns the key for an item.
 * @returns {Record<K, T>} An object where keys are generated by the iteratee and values are the corresponding elements.
 */
export function keyBy<T, K extends GroupKey>(
  array: T[] | null | undefined,
  iteratee: keyof T | ((item: T) => K)
): Record<K, T> {
  if (!isArray(array)) {
    return {} as Record<K, T>;
  }
  return array.reduce((obj, item) => {
    const key =
      typeof iteratee === 'function' ? iteratee(item) : (item[iteratee as keyof T] as unknown as K);
    obj[key] = item;
    return obj;
  }, {} as Record<K, T>);
}

/**
 * Sorts an array of objects by one or more properties, with optional custom compare functions.
 * @template T - The type of elements in the array.
 * @param {T[] | null | undefined} array - The array to sort.
 * @param {Array<keyof T | ((item: T) => any)>} iteratees - An array of property names or functions to sort by.
 * @param {Array<'asc' | 'desc'>} [orders=[]] - An array specifying 'asc' or 'desc' for each iteratee. Defaults to 'asc'.
 * @returns {T[]} A new sorted array.
 */
export function sortBy<T>(
  array: T[] | null | undefined,
  iteratees: Array<keyof T | ((item: T) => any)>,
  orders: Array<'asc' | 'desc'> = []
): T[] {
  if (!isArray(array)) {
    return [];
  }
  if (!iteratees || iteratees.length === 0) {
    return array.slice(); // Return a shallow copy if no iteratees
  }

  // Normalize orders array
  const normalizedOrders = iteratees.map((_, index) => orders[index] || 'asc');

  return [...array].sort((a, b) => {
    for (let i = 0; i < iteratees.length; i++) {
      const iteratee = iteratees[i];
      const order = normalizedOrders[i];

      const valA = typeof iteratee === 'function' ? iteratee(a) : a[iteratee as keyof T];
      const valB = typeof iteratee === 'function' ? iteratee(b) : b[iteratee as keyof T];

      let comparison = 0;
      if (valA < valB) {
        comparison = -1;
      } else if (valA > valB) {
        comparison = 1;
      }

      if (comparison !== 0) {
        return order === 'desc' ? comparison * -1 : comparison;
      }
    }
    return 0;
  });
}
